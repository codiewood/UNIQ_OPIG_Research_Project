#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 23 14:32:52 2019

@author: stats11
"""
import os,gzip,json

def maximum_valued_key(dictionary):
    values = list(dictionary.values())
    keys = list(dictionary.keys())
    return keys[values.index(max(values))]

def sort_alphanumerically(l): 
    convert = lambda text: int(text) if text.isdigit() else text.lower() 
    alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key)] 
    return sorted(l, key = alphanum_key)

class oas_file():
    def __init__(self, src): 
        meta_line = True
        seq_data = []
        for line in gzip.open(src,'rb'):
            if meta_line == True:
                    self.metadata = json.loads(line) #define metadata
                    meta_line=False
                    continue
            #Parse actual sequence data.
            basic_data = json.loads(line)
            seq_data.append(basic_data)
            
            #IMGT-Numbered sequence.
            d = json.loads(basic_data['data'])
            seq_data[-1]['data'] = d
        self.unique_sequences = len(seq_data) #define number of unique seqs
        self.sequence_data = seq_data
        if self.metadata['Chain'] == 'Heavy':
            self.regions = ['fwh1','cdrh1','fwh2','cdrh2','fwh3','cdrh3','fwh4']
        elif self.metadata['Chain'] == 'Light':
            self.regions = ['fwl1','cdrl1','fwl2','cdrl2','fwl3','cdrl3','fwl4']
    
    def get_error_counts(self):
        max_errors = 0
        correct_sequences = 0
        for data in self.sequence_data:
            if data['num_errors'] == "0":
                correct_sequences += 1
            elif int(data['num_errors']) > max_errors:
                max_errors = int(data['num_errors'])
        erroneous_sequences = self.unique_sequences - correct_sequences
        
        print("There are {} sequences thought to contain errors in this data."
              .format(erroneous_sequences))
        print("{} sequences are thought to contain 0 errors."
              .format(correct_sequences))
        
        for i in range(1, max_errors + 1):
            i_errors = 0
            for data in self.sequence_data:
                if int(data['num_errors']) == i:
                    i_errors += 1
            print("{} sequences are thought to contain {} errors."
                  .format(i_errors,i))            
    
    def get_region(self,region_name):
        region_sequences = []
        for data in self.sequence_data:
            region = data['data'][region_name]
            region_sequences.append(region)
        return region_sequences
    
    def most_common_sequence(self, region_name):
        reg_sequence_counter = {}
        for seq in self.get_region(region_name):
            key = json.dumps(seq, sort_keys=True)
            if key in reg_sequence_counter:
                reg_sequence_counter[key] += 1
            else:
                reg_sequence_counter[key] = 1
        most_common = maximum_valued_key(reg_sequence_counter)
        occurences = reg_sequence_counter[most_common]
        print("The {} sequence which was most common was {}, which appeared {} times."
              .format(region_name,most_common,occurences))